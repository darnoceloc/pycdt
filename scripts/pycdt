#!/usr/bin/env python

from __future__ import division, print_function, unicode_literals

"""
A script with tools for computing formation energies
of charged point defects, supporting multiple correction
schemes.
"""

__author__ = "Nils E. R. Zimmermann, Bharat Medasani"
__copyright__ = "Copyright 2012, The Materials Project"
__version__ = "1"
__maintainer__ = "Nils E. R. Zimmermann"
__email__ = "n.zimmermann@tuhh.de"
__date__ = "May 1, 2015"

import argparse

from collections import defaultdict

from monty.serialization import dumpfn, loadfn
from monty.json import MontyEncoder, MontyDecoder

from pymatgen.matproj.rest import MPRester
from pymatgen.core.structure import Structure
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer

from pycdt.core.defectsmaker import ChargedDefectsStructures
from pycdt.utils.vasp import make_vasp_defect_files, \
                              make_vasp_dielectric_files
from pycdt.utils.parse_calculations import PostProcess
from pycdt.utils.plotter import  DefectPlotter
from pycdt.corrections.defects_analyzer import get_correction_freysoldt, \
        get_correction_kumagai, DefectsAnalyzer
from pycdt.corrections.finite_size_charge_correction import KumagaiBulkInit



def print_error_message(err_str):
    print("\n=================================================================="
        "=============\n\nError: "+err_str)
    print("\n================================================================"
        "===============\n")


def generate_input_files(args):
    """
    Generates input files for VASP calculations that aim to determine
    formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).
    The primitive unit cell is obtained from the MP ID provided during
    script call.  

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    mp_id = args.mp_id
    struct_file = args.struct_file
    mapi_key = args.mapi_key
    nmax = args.nmax
    oxi_state = args.oxi_state
    oxi_range = args.oxi_range
    antisites = args.antisites
    include_interstitials = args.include_interstitials
    settings = {}
    if args.input_settings_file:
        settings = loadfn(args.input_settings_file)

    # error-checking
    if not struct_file and not mp_id:
        print_error_message("Neither structure, nor Materials Project " \
                            + "ID (MP-ID) provided!")
        return
    if nmax <= 0:
        print_error_message("maximal number of atoms per supercell"
            " must be larger than zero!")
        return

    # get primitive unit cell
    if mp_id:
        if not mapi_key:
            with MPRester() as mp:
                prim_struct = mp.get_structure_by_material_id(mp_id)
        else:
            with MPRester(mapi_key) as mp:
                prim_struct = mp.get_structure_by_material_id(mp_id)

        # transform to conventional unit cell
        conv_struct = SpacegroupAnalyzer( 
                prim_struct).get_conventional_standard_structure()
        make_vasp_dielectric_files(prim_struct)
    else:
        conv_struct = Structure.from_file(struct_file)
        make_vasp_dielectric_files(conv_struct, user_settings=settings)

    # manually set oxidation states if those were provided
    oxi_state_dict = {}
    if oxi_state:
        for i in range(len(oxi_state)):
            oxi_state_dict[oxi_state[i][0]] = int(oxi_state[i][1])
        if len(oxi_state_dict) != conv_struct.ntypesp:
            print_error_message("number of oxidation states"
                " provided does not match number of species in structure!")
            return

    # manually set oxidation-state ranges if those were provided
    oxi_range_dict = {}
    if oxi_range:
        for i in range(len(oxi_range)):
            oxi_range_dict[oxi_range[i][0]] = tuple(
                    [int(oxi_range[i][1]), int(oxi_range[i][2])])
        if len(oxi_range_dict) != conv_struct.ntypesp:
            print_error_message("number of distinct oxidation ranges"
                " provided does not match number of species in structure!")
            return

    # finally, generate VASP input files for defect calculations
    def_structs = ChargedDefectsStructures(
            conv_struct, max_min_oxi=oxi_range_dict, 
            oxi_states=oxi_state_dict, antisites_flag=antisites,
            include_interstitials=include_interstitials,
            cellmax=nmax)
    make_vasp_defect_files(
            def_structs.defects,
            conv_struct.composition.reduced_formula, 
            user_settings=settings)


def parse_vasp_output(args):
    """
    Parses output files from VASP calculations that aim to determine
    formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    mp_id = args.mp_id
    mapi_key = args.mapi_key
    root_fldr = args.root_fldr
    #if args.defect_data_file_name == 'None':
    #    defect_data_file_name = None
    #else:
    #    defect_data_file_name = args.defect_data_file_name
    #if args.corrections_file_name == 'None':
    #    corrections_file_name = None
    #else:
    #    corrections_file_name = args.corrections_file_name
    #plot_results = args.plot_results
    #epsilon = args.epsilon

    # error-checking
    if not mp_id:
        print_error_message("No Materials Project structure ID provided!")
        return

    # parse results to get defect data and correction terms
    defect_data = PostProcess(root_fldr, mp_id, mapi_key).compile_all()
    #if defect_data_file_name is not None:
    dumpfn(defect_data, args.defect_data_file_name, cls=MontyEncoder, indent=2)
    #bulk = defect_data['bulk_entry']
    #defects = defect_data['defects']
    #if epsilon is None:
    #    epsilon = defect_data['epsilon']
    #else:
    #    defect_data['epsilon'] = epsilon
    #corrections = defaultdict(list)
    #for defect in defects:
    #    correction = get_correction(defect, bulk, epsilon)
    #    defect.charge_correction = correction
    #    corrections[defect._name].append({'charge_correction': correction,'charge':defect._charge})

    # output results, if applicable
    #if corrections_file_name is not None:
    #    dumpfn(corrections, corrections_file_name, cls=MontyEncoder, indent=2)

    # plot results, if applicable
    #if plot_results:
    #    pass # go on here


def compute_corrections(args):
    """
    Computes formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    defect_data_file_name = args.defect_data_file_name
    corrections_file_name = args.corrections_file_name
    plot_results = args.plot_results
    correction_method = args.correction_method


    # parse results to get defect data and correction terms
    defect_data = loadfn(defect_data_file_name, cls=MontyDecoder)
    if args.epsilon:
        epsilon = args.epsilon
    else:
        epsilon = defect_data['epsilon']

    bulk = defect_data['bulk_entry']
    defects = defect_data['defects']
    corrections = defaultdict(list)
    if correction_method=='freysoldt':
        for defect in defects:
            print ('defect_name: ', defect._full_name)
            print ('-----------------------------------------\n\n')
            correction = get_correction_freysoldt(
                    defect, bulk, epsilon)
            defect.charge_correction = correction
            corrections[defect._name].append({
                'charge_correction': correction, 'charge':defect._charge})
    else:    
        locpot_path_blk = bulk.data['locpot_path']
        encut = bulk.data['encut']
        kumagai_init = KumagaiBulkInit(locpot_path_blk, epsilon, 
                                       encut, tolerance=0.0001, silence=False)
        for defect in defects:
            print ('defect_name: ', defect._full_name)
            print ('-----------------------------------------\n\n')
            correction = get_correction_kumagai(
                    defect, kumagai_init, epsilon)
            defect.charge_correction = correction
            corrections[defect._name].append({
                'charge_correction': correction, 'charge':defect._charge})

    dumpfn(corrections, corrections_file_name, cls=MontyEncoder, indent=2)


def compute_formation_energies(args):
    """
    Computes formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    defect_data_file_name = args.defect_data_file_name
    corrections_file_name = args.corrections_file_name
    plot_results = args.plot_results
    #correction_method = args.correction_method


    # parse results to get defect data and correction terms
    defect_data = loadfn(defect_data_file_name, cls=MontyDecoder)
    epsilon_tensor = args.epsilon_tensor
    if epsilon_tensor is None:
        epsilon_tensor = defect_data['epsilon']
    defects = defect_data['defects']
    correction_data = loadfn(corrections_file_name)  

    for parsed_defect in defects:
        name_def = parsed_defect._name
        q = parsed_defect._charge
        for entry in correction_data[name_def]:
            if q == entry['charge']:
                correction = entry['charge_correction']
                break
        parsed_defect.charge_correction = correction

    # Gap
    if not args.bandgap:
        bandgap = defect_data['gap']['energy']
    else:
        bandgap = args.bandgap

    vbm = defect_data['vbm']
    blk_entry = defect_data['bulk_entry']
    mu_range = defect_data['mu_range']

    poor_mu = mu_range.values()[0]['poor'] # Only one pair in mu_range dict
    rich_mu = mu_range.values()[0]['rich']
    specie = mu_range.keys()[0]
    #o_poor_da = DefectsAnalyzer(blk_entry, vbm, o_poor_mu, bandgap['energy'])
    #o_rich_da = DefectsAnalyzer(blk_entry, vbm, o_rich_mu, bandgap['energy'])
    poor_da = DefectsAnalyzer(blk_entry, vbm, poor_mu, bandgap)
    rich_da = DefectsAnalyzer(blk_entry, vbm, rich_mu, bandgap)
    for defect in defects:
        rich_da.add_parsed_defect(defect)
    for defect in defects:
        poor_da.add_parsed_defect(defect)
    plotter = DefectPlotter(rich_da)
    form_en_plot = plotter.get_plot_form_energy()
    form_en_plot.savefig(specie+'_rich_defect_form_energy.eps')
    plotter = DefectPlotter(poor_da)
    form_en_plot = plotter.get_plot_form_energy()
    form_en_plot.savefig(specie+'_poor_defect_form_enenergy.eps')


    #bulk = defect_data['bulk_entry']
    #defects = defect_data['defects']
    #print (defects)
    #corrections = defaultdict(list)
    #for defect in defects:
    #    print ('defect_name: ', defect._full_name)
    #    print ('-----------------------------------------\n\n')
    #    correction = get_correction_new(defect, bulk, epsilon_tensor, type=correction_method)
    #    #correction = get_correction(defect, bulk, epsilon_tensor, type=correction_method)
    #    defect.charge_correction = correction
    #    corrections[defect._name].append({'charge_correction': correction,'charge':defect._charge})
#
    # plot results, if applicable
    #if plot_results:
    #    pass # go on here
    #parsed_data = loadfn('defect_data.json',cls=MontyDecoder)
    
    

def main():
    parser = argparse.ArgumentParser(description="""
        PyCDT is a script that generates vasp input files, parses vasp output
        files, and computes the formation energy of charged defects.
        This script works based on several sub-commands with their own options.
        To see the options for the sub-commands, type
        "pycdt sub-command -h".""",
        epilog="""
        Authors: N. E. R. Zimmermann, B. Medasani, D. Broberg, G. Hautier
        Version: {}
        Last updated: {}""".format(__version__, __date__))


    subparsers = parser.add_subparsers()
    struct_string = "Input structure. Can accept multiple file formats. " \
        "Supported formats include CIF, POSCAR/CONTCAR, CHGCAR, LOCPOT, "\
        "vasprun.xml, CSSR, Netcdf and pymatgen's JSON serialized structures."
    mp_id_string = "Materials Project id of the structure.\nFor more info on " \
        "Materials Project, please, visit www.materialsproject.org."
    mapi_string = "Your Materials Project REST API key.\nFor more info, " \
        "please, visit www.materialsproject.org/open."
    nmax_string = "Maximum number of atoms in supercell.\nThe default is" \
        " 128.\nKeep in mind that the number of atoms in the supercell may" \
        " vary from the provided number including the default."
    oxi_state_string = "Oxidation state for an element.\nTwo arguments" \
        " are expected: the element type for which the oxidation state is" \
        " to be specified and the oxidation state (e.g., --oxi_state As -3)."
    oxi_range_string = "Oxidation range for an element.\nThree arguments" \
        " are expected: the element type for which the oxidation state range is" \
        " to be specified as well as the lower and the upper limit of the" \
        " range (e.g., --oxi_range As -3 5)."
    no_antisites_string = "Optional flag to indicate that anti-site defects" \
        " should not be generated."
    include_interstitials_string = "Optional flag to indicate that" \
        " interstitial defects should be generated."
    input_settings_string = "Supply VASP input settings for INCAR, KPOINTS in" \
        " the specified YAML/JSON file."
    root_fldr_string = "Path (relative or absolute) to directory" \
        " in which data of charged point-defect calculations for" \
        " a particular system are to be found."
    defect_data_file_name_string = "Name of output file for defect data" \
        " obtained from parsing VASP's files of charged-defect" \
        " calculations in json format.\nDefault is" \
        " \"defect_data.json\"; \"None\" suppresses output."
    corrections_file_name_string = "Name of output file for data on" \
        " correction terms to formation energies of charged defects" \
        " in json format.\nDefault is \"corrections.json\";" \
        " \"None\" suppresses output."
    plot_results_string = "Optional flag to indicate that results" \
        " should not be plotted."
    epsilon_string = "Optional: provide a dielectric constant to be" \
        " used in the correction terms of the defect-formation energies.\n" \
        "Only a scalar is accepted.\nIf not provided, the dielectric" \
        " constant is extracted from the corresponding VASP calculation.\n" \
        "Note that this evaluation script expects the dielectric" \
        " constant calculation to have been performed to properly analyze" \
        " the data."
    correction_string = "Method to be used to compute finite size charge " \
        "correction for the defect-formation energies.\n" \
        "Options are `freysoldt' and `kumagai'.\n" \
        "If not provided, Freysoldt method is assumed." 
    bandgap_string = "User defined band gap to plot the defect formation " \
        "energies.\nBy default, Materials Project (MP) bandgap is " \
        "used.\nHowever, MP bandgap could be a severly underpredicted value." 


    parser_input_files = subparsers.add_parser(
            "generate_input_files",
            help="Generates Vasp input files for charged point defects.")
    parser_input_files.add_argument("-s", "--structure_file", default=None, 
                                    dest="struct_file", help=struct_string) 
    parser_input_files.add_argument("-i", "-id", "--mp_id", default=None,
                                    type=str.lower, dest="mp_id", 
                                    help=mp_id_string)
    parser_input_files.add_argument("-k", "-key", "--mapi_key", default=None,
                                    dest="mapi_key", help=mapi_string)
    parser_input_files.add_argument("-n", "--nmax", type=int, default=80,
                                    dest="nmax", help=nmax_string)
    parser_input_files.add_argument("-or", "--oxi_range", action='append',
                                    type=str, nargs=3, dest="oxi_range",
                                    help=oxi_range_string)
    parser_input_files.add_argument("-os", "--oxi_state", action='append',
                                    type=str, nargs=2, dest="oxi_state",
                                    help=oxi_state_string)
    parser_input_files.add_argument("-noa", "--no_antisites",
                                    action='store_false', dest="antisites",
                                    help=no_antisites_string)
    parser_input_files.add_argument("-ii", "--include_interstitials",
                                    action='store_false', dest="include_interstitials",
                                    help=include_interstitials_string)
    parser_input_files.add_argument("-is", "--input_settings_file", default=None,
                                    type=str, dest="input_settings_file",
                                    help=input_settings_string)
    parser_input_files.set_defaults(func=generate_input_files)

    parser_vasp_output = subparsers.add_parser(
            "parse_vasp_output",
            help="Parses VASP output for calculation of formation energies of"
             " charged point defects.")
    parser_vasp_output.add_argument("-i", "-id", "--mp_id", type=str.lower,
                                    dest="mp_id", help=mp_id_string)
    parser_vasp_output.add_argument("-k", "-key", "--mapi_key", default=None,
                                    dest="mapi_key", help=mapi_string)
    parser_vasp_output.add_argument("-d", "-dir", "--directory", default=None,
                                    dest="root_fldr", help=root_fldr_string)
    parser_vasp_output.add_argument("-o", "-output", "--output_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    #parser_vasp_output.add_argument("-c", "-cfn", "--corrections_file_name",
    #                                default="corrections.json",
    #                                dest="corrections_file_name",
    #                                help=corrections_file_name_string)
    #parser_vasp_output.add_argument("-np", "-npr", "--not_plot_results",
    #                                action='store_false', dest="plot_results",
    #                                help=not_plot_results_string)
    #parser_vasp_output.add_argument("-e", "-eps", "--epsilon",
    #                                "--dielectric_constant", default=None,
    #                                dest="epsilon", help=epsilon_string)
    parser_vasp_output.set_defaults(func = parse_vasp_output)

    parser_compute_corrections = subparsers.add_parser(
            "compute_corrections",
            help="Computes correction for finite size supercell error "
            "associated with charged point defects.")
    parser_compute_corrections.add_argument("-i", "--input_defect_data_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    parser_compute_corrections.add_argument("-o", "--output_corrections_file_name",
                                    default="corrections.json",
                                    dest="corrections_file_name",
                                    help=corrections_file_name_string)
    parser_compute_corrections.add_argument("-p", "--plot_results",
                                    action='store_true', dest="plot_results",
                                    help=plot_results_string)
    parser_compute_corrections.add_argument("-e", "-eps", "--epsilon", 
                                    "--dielectric_constant", type=float, 
                                    default=None, dest="epsilon", 
                                    help=epsilon_string)
    parser_compute_corrections.add_argument("-c", "-cm", "--correction_method",
                                    type=str, default="freysoldt",
                                    dest="correction_method",
                                    help=correction_string)
    parser_compute_corrections.set_defaults(func = compute_corrections)

    parser_compute_energies = subparsers.add_parser(
            "compute_formation_energies",
            help="Computes formation energies of charged point defects from "
            "the parsed VASP output.")
    parser_compute_energies.add_argument("-i", "-if", "--input_defect_data_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    parser_compute_energies.add_argument("-c", "-cf", "--corrections_file_name",
                                    default="corrections.json",
                                    dest="corrections_file_name",
                                    help=corrections_file_name_string)
    parser_compute_energies.add_argument("-p", "--plot_results",
                                    action='store_true', dest="plot_results",
                                    help=plot_results_string)
    parser_compute_energies.add_argument("-e", "-eps", "--epsilon",
                                    "--dielectric_constant", default=None,
                                    dest="epsilon_tensor", help=epsilon_string)
    parser_compute_energies.add_argument("-bg", "--bandgap",
                                    type=float, default=0,
                                    dest="bandgap",
                                    help=bandgap_string)
    parser_compute_energies.set_defaults(func = compute_formation_energies)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
