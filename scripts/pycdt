#!/usr/bin/env python

from __future__ import division, print_function, unicode_literals

"""
A script with tools for computing formation energies
of charged point defects, supporting multiple correction
schemes.
"""

__author__ = "Nils E. R. Zimmermann, Bharat Medasani"
__copyright__ = "Copyright 2012, The Materials Project"
__version__ = "1"
__maintainer__ = "Nils E. R. Zimmermann"
__email__ = "n.zimmermann@tuhh.de"
__date__ = "May 1, 2015"

import argparse
import os

from collections import defaultdict

from monty.serialization import dumpfn, loadfn
from monty.json import MontyEncoder, MontyDecoder

from pymatgen.matproj.rest import MPRester
from pymatgen.core.structure import Structure
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer

from pycdt.core.defectsmaker import ChargedDefectsStructures
from pycdt.utils.vasp import make_vasp_defect_files, \
                              make_vasp_dielectric_files
from pycdt.utils.parse_calculations import PostProcess
from pycdt.utils.plotter import  DefectPlotter
from pycdt.corrections.defects_analyzer import get_correction_freysoldt, \
        get_correction_kumagai, DefectsAnalyzer
from pycdt.corrections.kumagai_correction import KumagaiBulkInit



def print_error_message(err_str):
    print("\n=================================================================="
        "=============\n\nError: "+err_str)
    print("\n================================================================"
        "===============\n")


def generate_input(args):
    """
    Generates input files for VASP calculations that aim to determine
    formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).
    The primitive unit cell is obtained from the MP ID provided during
    script call.  

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    mp_id = args.mp_id
    struct_file = args.struct_file
    mapi_key = args.mapi_key
    nmax = args.nmax
    oxi_state = args.oxi_state
    oxi_range = args.oxi_range
    antisites = args.antisites
    include_interstitials = args.include_interstitials
    interstitial_elements = args.interstitial_elements
    settings = {}
    if args.input_settings_file:
        settings = loadfn(args.input_settings_file)

    # error-checking
    if not struct_file and not mp_id:
        print_error_message("Neither structure, nor Materials Project " \
                            + "ID (MP-ID) provided!")
        return
    if nmax <= 0:
        print_error_message("maximal number of atoms per supercell"
            " must be larger than zero!")
        return

    # get primitive unit cell
    if mp_id:
        if not mapi_key:
            with MPRester() as mp:
                prim_struct = mp.get_structure_by_material_id(mp_id)
        else:
            with MPRester(mapi_key) as mp:
                prim_struct = mp.get_structure_by_material_id(mp_id)

        # transform to conventional unit cell
        conv_struct = SpacegroupAnalyzer( 
                prim_struct).get_conventional_standard_structure()
        make_vasp_dielectric_files(prim_struct, user_settings=settings)
    else:
        conv_struct = Structure.from_file(struct_file)
        make_vasp_dielectric_files(conv_struct, user_settings=settings)

    # manually set oxidation states if those were provided
    oxi_state_dict = {}
    if oxi_state:
        for i in range(len(oxi_state)):
            oxi_state_dict[oxi_state[i][0]] = int(oxi_state[i][1])
        #if len(oxi_state_dict) != conv_struct.ntypesp:
        #    print_error_message("number of oxidation states"
        #        " provided does not match number of species in structure!")
        #    return

    # manually set oxidation-state ranges if those were provided
    oxi_range_dict = {}
    if oxi_range:
        for i in range(len(oxi_range)):
            oxi_range_dict[oxi_range[i][0]] = tuple(
                    [int(oxi_range[i][1]), int(oxi_range[i][2])])
        #if len(oxi_range_dict) != conv_struct.ntypesp:
        #    print_error_message("number of distinct oxidation ranges"
        #        " provided does not match number of species in structure!")
        #    return

    # Substitution defects if those were provided
    substitutions = {}
    if args.substitutions:
        for i, sub in enumerate(args.substitutions):
            substitutions[sub[0]] = sub[1:]


    # finally, generate VASP input files for defect calculations
    def_structs = ChargedDefectsStructures(
            conv_struct, max_min_oxi=oxi_range_dict, 
            oxi_states=oxi_state_dict, antisites_flag=antisites,
            substitutions=substitutions,
            include_interstitials=include_interstitials,
            interstitial_elements=interstitial_elements,
            cellmax=nmax)
    make_vasp_defect_files(
            def_structs.defects,
            conv_struct.composition.reduced_formula, 
            user_settings=settings)


def parse_output(args):
    """
    Parses output files from VASP calculations that aim to determine
    formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    mp_id = args.mp_id
    mapi_key = args.mapi_key
    root_fldr = args.root_fldr
    #if args.defect_data_file_name == 'None':
    #    defect_data_file_name = None
    #else:
    #    defect_data_file_name = args.defect_data_file_name
    #if args.corrections_file_name == 'None':
    #    corrections_file_name = None
    #else:
    #    corrections_file_name = args.corrections_file_name
    #plot_results = args.plot_results
    #epsilon = args.epsilon

    # error-checking;
    if not mp_id:
        print_error_message("No Materials Project structure ID provided! (proceeding anyway)")
        #return
        mp_id=None

    # parse results to get defect data and correction terms
    defect_data = PostProcess(root_fldr, mp_id, mapi_key).compile_all()
    #if defect_data_file_name is not None:
    dumpfn(defect_data, args.defect_data_file_name, cls=MontyEncoder, indent=2)
    #bulk = defect_data['bulk_entry']
    #defects = defect_data['defects']
    #if epsilon is None:
    #    epsilon = defect_data['epsilon']
    #else:
    #    defect_data['epsilon'] = epsilon
    #corrections = defaultdict(list)
    #for defect in defects:
    #    correction = get_correction(defect, bulk, epsilon)
    #    defect.charge_correction = correction
    #    corrections[defect._name].append({'charge_correction': correction,'charge':defect._charge})

    # output results, if applicable
    #if corrections_file_name is not None:
    #    dumpfn(corrections, corrections_file_name, cls=MontyEncoder, indent=2)

    # plot results, if applicable
    #if plot_results:
    #    pass # go on here


def compute_corrections(args):
    """
    TODO: have option to suppress potential plots (but for now want to plot them to make sure correction is working)
    ----------
    Computes corrections for the charged point defects
    Supported so-far: Freysoldt method, Extended Freysoldt method

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    defect_data_file_name = args.defect_data_file_name
    corrections_file_name = args.corrections_file_name
    plot_results = args.plot_results
    correction_method = args.correction_method


    # parse results to get defect data and correction terms
    defect_data = loadfn(defect_data_file_name, cls=MontyDecoder)
    if args.epsilon:
        epsilon = args.epsilon
    else:
        epsilon = defect_data['epsilon']

    bulk = defect_data['bulk_entry']
    defects = defect_data['defects']
    corrections = defaultdict(list)
    blklpt=None  #for speeding up correction loop by storing bulk Locpot object
    if correction_method=='freysoldt':
        for defect in defects:
            print ('defect_name: ', defect._full_name)
            print ('-----------------------------------------\n\n')
            #correction = get_correction_freysoldt(
            #        defect, bulk, epsilon)
            if not blklpt:
                correction,blklpt = get_correction_freysoldt(
                                    defect, bulk, epsilon,title=defect._full_name)  #title outputs freysoldt pot. plots
            else:
                correction,blklpt = get_correction_freysoldt(
                        defect, blklpt, epsilon,title=defect._full_name)
            defect.charge_correction = correction
            corrections[defect._name].append({
                'charge_correction': correction, 'charge':defect._charge})
    else:    
        locpot_path_blk = bulk.data['locpot_path']
        encut = bulk.data['encut']
        kumagai_init = KumagaiBulkInit(locpot_path_blk, epsilon, 
                                       encut, tolerance=0.0001, silence=False)
        for defect in defects:
            print ('defect_name: ', defect._full_name)
            print ('-----------------------------------------\n\n')
            correction = get_correction_kumagai(
                    defect, kumagai_init, epsilon)
            defect.charge_correction = correction
            corrections[defect._name].append({
                'charge_correction': correction, 'charge':defect._charge})

    dumpfn(corrections, corrections_file_name, cls=MontyEncoder, indent=2)


def compute_formation_energies(args):
    """
    Computes formation energies of charged point defects by (possibly) applying
    correction terms (supported so-far: correction due to Freysoldt
    et al., Phys. Rev. Lett., 2009).

    Args:
        args (Namespace): contains the parsed command-line arguments for
            this command.
    """

    # initialize variables
    defect_data_file_name = args.defect_data_file_name
    corrections_file_name = args.corrections_file_name
    plot_results = args.plot_results
    #correction_method = args.correction_method


    # parse results to get defect data and correction terms
    defect_data = loadfn(defect_data_file_name, cls=MontyDecoder)
    epsilon_tensor = args.epsilon_tensor #this is unneccessary...
    if epsilon_tensor is None:
        epsilon_tensor = defect_data['epsilon']
    defects = defect_data['defects']

    if os.path.isfile(corrections_file_name):
        correction_data = loadfn(corrections_file_name)  
        for parsed_defect in defects:
            name_def = parsed_defect._name
            q = parsed_defect._charge
            for entry in correction_data[name_def]:
                if q == entry['charge']:
                    correction = entry['charge_correction']
                    break
            parsed_defect.charge_correction = correction
    elif corrections_file_name == "corrections.json":  # Default filename
        pass # Don't bother, the user is not worried about corrections
    else:
        raise OSError([2, "File not found", corrections_file_name])

    # Gap
    if not args.bandgap:
        bandgap = defect_data['gap']
    else:
        bandgap = args.bandgap

    vbm = defect_data['vbm']
    blk_entry = defect_data['bulk_entry']
    mu_range = defect_data['mu_range']

    for region, mu in mu_range.items():
        da = DefectsAnalyzer(blk_entry, vbm, mu, bandgap)
        for defect in defects:
            da.add_parsed_defect(defect)

        if region == mu_range.keys()[0]:
            da_trans = da.get_transition_levels()
            print ("===============\nDefect Transition Levels (eV):\n==============")
            for dfct_name, trans_lvls in da_trans.items():
                print (dfct_name)
                ky_vals = sorted(trans_lvls.items(), key=lambda x: x[0][0])
                for qpair, trans_lvl in ky_vals:
                    print ("{}: {}".format(qpair, trans_lvl))

        if args.plot_results:
            plotter = DefectPlotter(da)
            form_en_plot = plotter.get_plot_form_energy()
            form_en_plot.savefig(region+'_region_defect_form_energy.eps', bbox_inches='tight')
            print('printed ',region,' plot')



def main():
    parser = argparse.ArgumentParser(description="""
        PyCDT is a script that generates vasp input files, parses vasp output
        files, and computes the formation energy of charged defects.
        This script works based on several sub-commands with their own options.
        To see the options for the sub-commands, type
        "pycdt sub-command -h".""",
        epilog="""
        Authors: N. E. R. Zimmermann, B. Medasani, D. Broberg, G. Hautier
        Version: {}
        Last updated: {}""".format(__version__, __date__))


    subparsers = parser.add_subparsers()
    struct_string = "Input structure. Can accept multiple file formats. " \
        "Supported formats include CIF, POSCAR/CONTCAR, CHGCAR, LOCPOT, "\
        "vasprun.xml, CSSR, Netcdf and pymatgen's JSON serialized structures."
    mp_id_string = "Materials Project id of the structure.\nFor more info on " \
        "Materials Project, please, visit www.materialsproject.org."
    mapi_string = "Your Materials Project REST API key.\nFor more info, " \
        "please, visit www.materialsproject.org/open."
    nmax_string = "Maximum number of atoms in supercell.\nThe default is" \
        " 128.\nKeep in mind that the number of atoms in the supercell may" \
        " vary from the provided number including the default."
    oxi_state_string = "Oxidation state for an element.\nTwo arguments" \
        " are expected: the element type for which the oxidation state is" \
        " to be specified and the oxidation state (e.g., --oxi_state As -3)."
    oxi_range_string = "Oxidation range for an element.\nThree arguments" \
        " are expected: the element type for which the oxidation state range is" \
        " to be specified as well as the lower and the upper limit of the" \
        " range (e.g., --oxi_range As -3 5)."
    no_antisites_string = "Optional flag to indicate that anti-site defects" \
        " should not be generated."
    include_interstitials_string = "Optional flag to indicate that" \
        " interstitial defects should be generated."
    interstitial_elements_string = "Explicit list of elements" \
        " that are to be considered for interstitial generation. " \
        " If no elements are given, intrinsic interstitials" \
        " are considered."
    substitutions_string = "Substitutional defects (optional) to be generated.\n" \
        " Minimum of two arguments are expected: the element on which the " \
        " substitution is to applied as well as the substitution elements " \
        " (e.g., --sub As P N O)."
    input_settings_string = "Supply VASP input settings for INCAR, KPOINTS in" \
        " the specified YAML/JSON file."
    root_fldr_string = "Path (relative or absolute) to directory" \
        " in which data of charged point-defect calculations for" \
        " a particular system are to be found.  Default is the" \
        " current working directory."
    defect_data_file_name_string = "Name of output file for defect data" \
        " obtained from parsing VASP's files of charged-defect" \
        " calculations in json format.\nDefault is" \
        " \"defect_data.json\"; \"None\" suppresses output."
    corrections_file_name_string = "Name of output file for data on" \
        " correction terms to formation energies of charged defects" \
        " in json format.\nDefault is \"corrections.json\";" \
        " \"None\" suppresses output."
    plot_results_string = "Optional flag to indicate that results" \
        " should be plotted."
    epsilon_string = "Optional: provide a dielectric constant to be" \
        " used in the correction terms of the defect-formation energies.\n" \
        "Only a scalar is accepted.\nIf not provided, the dielectric" \
        " constant is extracted from the corresponding VASP calculation.\n" \
        "Note that this evaluation script expects the dielectric" \
        " constant calculation to have been performed to properly analyze" \
        " the data."
    correction_string = "Method to be used to compute finite size charge " \
        "correction for the defect-formation energies.\n" \
        "Options are `freysoldt' and `kumagai'.\n" \
        "If not provided, Freysoldt method is assumed." 
    bandgap_string = "User defined band gap to plot the defect formation " \
        "energies.\nBy default, Materials Project (MP) bandgap is " \
        "used.\nHowever, MP bandgap could be a severly underpredicted value." 


    parser_input_files = subparsers.add_parser(
            "generate_input",
            help="Generates Vasp input files for charged point defects.")
    parser_input_files.add_argument("-s", "--structure_file", default=None, 
                                    dest="struct_file", help=struct_string) 
    parser_input_files.add_argument("-i", "--mpid", default=None,
                                    type=str.lower, dest="mp_id", 
                                    help=mp_id_string)
    parser_input_files.add_argument("-k",  "--mapi_key", default=None,
                                    dest="mapi_key", help=mapi_string)
    parser_input_files.add_argument("-n", "--nmax", type=int, default=80,
                                    dest="nmax", help=nmax_string)
    parser_input_files.add_argument("-or", "--oxi_range", action='append',
                                    type=str, nargs=3, dest="oxi_range",
                                    help=oxi_range_string)
    parser_input_files.add_argument("-os", "--oxi_state", action='append',
                                    type=str, nargs=2, dest="oxi_state",
                                    help=oxi_state_string)
    parser_input_files.add_argument("-noa", "--no_antisites",
                                    action='store_false', dest="antisites",
                                    help=no_antisites_string)
    parser_input_files.add_argument("-ii", "--include_interstitials",
                                    action='store_true', dest="include_interstitials",
                                    help=include_interstitials_string)
    parser_input_files.add_argument("interstitial_elements", type=str,
                                    default=[], nargs="*", \
                                    help=interstitial_elements_string)
    parser_input_files.add_argument("--sub", action='append', type=str,
                                    nargs="+", dest='substitutions',\
                                    help=substitutions_string)
    parser_input_files.add_argument("-is", "--input_settings_file", default=None,
                                    type=str, dest="input_settings_file",
                                    help=input_settings_string)
    parser_input_files.set_defaults(func=generate_input)

    os_path_abspath_this = os.path.abspath(".")
    parser_vasp_output = subparsers.add_parser(
            "parse_output",
            help="Parses VASP output for calculation of formation energies of"
             " charged point defects.")
    parser_vasp_output.add_argument("-i", "--mpid", type=str.lower,
                                    dest="mp_id", help=mp_id_string)
    parser_vasp_output.add_argument("-k", "--mapi_key", default=None,
                                    dest="mapi_key", help=mapi_string)
    parser_vasp_output.add_argument("-d", "--directory",
                                    default=os_path_abspath_this,
                                    dest="root_fldr",
                                    help=root_fldr_string)
    parser_vasp_output.add_argument("-o", "--output_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    #parser_vasp_output.add_argument("-c", "-cfn", "--corrections_file_name",
    #                                default="corrections.json",
    #                                dest="corrections_file_name",
    #                                help=corrections_file_name_string)
    #parser_vasp_output.add_argument("-np", "-npr", "--not_plot_results",
    #                                action='store_false', dest="plot_results",
    #                                help=not_plot_results_string)
    #parser_vasp_output.add_argument("-e", "-eps", "--epsilon",
    #                                "--dielectric_constant", default=None,
    #                                dest="epsilon", help=epsilon_string)
    parser_vasp_output.set_defaults(func = parse_output)

    parser_compute_corrections = subparsers.add_parser(
            "compute_corrections",
            help="Computes correction for finite size supercell error "
            "associated with charged point defects.")
    parser_compute_corrections.add_argument("-i", "--input_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    parser_compute_corrections.add_argument("-o", "--output_file_name",
                                    default="corrections.json",
                                    dest="corrections_file_name",
                                    help=corrections_file_name_string)
    parser_compute_corrections.add_argument("-p", "--plot_results",
                                    action='store_true', dest="plot_results",
                                    help=plot_results_string)
    parser_compute_corrections.add_argument("-e",  "--epsilon", type=float, 
                                    default=None, dest="epsilon", 
                                    help=epsilon_string)
    parser_compute_corrections.add_argument("-c", "--correction_method",
                                    type=str, default="freysoldt",
                                    dest="correction_method",
                                    help=correction_string)
    parser_compute_corrections.set_defaults(func = compute_corrections)

    parser_compute_energies = subparsers.add_parser(
            "compute_formation_energies",
            help="Computes formation energies of charged point defects from "
            "the parsed VASP output.")
    parser_compute_energies.add_argument("-i", "--input_file_name",
                                    default="defect_data.json",
                                    dest="defect_data_file_name",
                                    help=defect_data_file_name_string)
    parser_compute_energies.add_argument("-c", "--corrections_file_name",
                                    default="corrections.json",
                                    dest="corrections_file_name",
                                    help=corrections_file_name_string)
    parser_compute_energies.add_argument("-p", "--plot_results",
                                    action='store_true', dest="plot_results",
                                    help=plot_results_string)
    parser_compute_energies.add_argument("-e", "--epsilon", default=None,
                                    dest="epsilon_tensor", help=epsilon_string)
    parser_compute_energies.add_argument("-bg", "--bandgap",
                                    type=float, default=0,
                                    dest="bandgap",
                                    help=bandgap_string)
    parser_compute_energies.set_defaults(func = compute_formation_energies)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
